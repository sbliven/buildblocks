#!/bin/bash

#############################################################################
# bash 3 or newer ...
#
if [ ${BASH_VERSINFO:-0} -lt 3 ]; then
	echo "BASH version ${BASH_VERSION} ist not supported! You need at least version 3..."
	return
fi

#############################################################################
# implement module comand as function
#
module() {
	local -r modulecmd="${PMODULES_HOME}/bin/modulecmd"

	local -a args=()
	local -a switches=()
	local -a sub_switches=()
	local subcommand=''

	while (( $# > 0 )); do
		case $1 in
		-u|--userlvl )
			switches+=( $1 $2 )
			shift 2
			;;
		-* )
			switches+=( $1 )
			shift
			;;
		[a-z]* )
			subcommand=$1
			shift
			break
			;;
		esac
	done

	while (( $# > 0 ));do
		case $1 in
			-* )
				sub_switches+=( $1 )
				;;
			[/~a-zA-Z]* )
				args+=( $1 )
				;;
		esac
		shift
	done

	if [[ ${subcommand} == '' ]]; then
	        subcommand='help'
	fi
	if (( ${#args[@]} == 0 )); then
	        eval $( "${modulecmd}" bash ${switches[@]} "${subcommand}" "${sub_switches[@]}" )
	else
		for arg in "${args[@]}"; do
			eval $( "${modulecmd}" bash ${switches[@]} "${subcommand}" "${sub_switches[@]}" "${arg}" )
		done
	fi
}
export -f module

#############################################################################
# helper functions
#
append_path () {
	local -r P=$1
	local -r d=$2

        if ! echo ${!P} | egrep -q "(^|:)${d}($|:)" ; then
		if [[ -z ${!P} ]]; then
			eval $P=${d}
		else
			eval $P="${!P}:${d}"
        	fi
	fi
}

prepend_path () {
	local -r P=$1
	local -r d=$2

        if ! echo ${!P} | egrep -q "(^|:)${d}($|:)" ; then
		if [[ -z ${!P} ]]; then
			eval $P=${d}
		else
			eval $P="${d}:${!P}"
        	fi
	fi
}

#
# Replace or remove a directory in a path variable.
#
# To remove a dir:
#	replace_path PATH <pattern>
#
# To replace a dir:
#	replace_path PATH <pattern> /replacement/path
#
# Args:
#	$1 name of the shell variable to set (e.g. PATH)
#	$2 a grep pattern identifying the element to be removed/replaced
#	$3 the replacement string (use "" for removal)
#
# Based on solution published here:
# https://stackoverflow.com/questions/273909/how-do-i-manipulate-path-elements-in-shell-scripts 
#
function replace_path () {
	local -r path=$1
	local -r removepat=$2
	local -r replacestr=$3

	local -r removestr=$(echo "${!path}" | tr ":" "\n" | grep -m 1 "^$removepat\$")
    	export $path=$(echo "${!path}" | tr ":" "\n" | sed "s:^${removestr}\$:${replacestr}:" |
                   sed '/^\s*$/d' | tr "\n" ":" | sed -e 's|^:||' -e 's|:$||')
}

save_env() {
	local s=''
	while (( $# > 0 )); do
		s+="$( typeset -p $1 );"
		shift
	done
	echo export PMODULES_ENV=$( "${PMODULES_HOME}/bin/base64" --wrap=0 <<< "$s" )	
}

#module purge

#############################################################################
# setup environment
#
declare -x LOADEDMODULES=''
declare -x _LMFILES_=''
declare -x PMODULES_USED_GROUPS=''
declare -x MODULEPATH=''
for f in ${PMODULES_DEFAULT_GROUPS//:/ }; do
	append_path MODULEPATH "${PSI_PREFIX}/${PSI_MODULES_ROOT}/$f"
	append_path PMODULES_USED_GROUPS "${f}"
done
declare -x USED_RELEASES=''
for r in ${PMODULES_DEFAULT_RELEASES//:/ }; do
	append_path USED_RELEASES "${r}"
done

eval $(save_env USED_RELEASES PMODULES_DEFAULT_RELEASES PMODULES_DEFAULT_GROUPS PMODULES_DEFINED_RELEASES)
unset USED_RELEASES
unset PMODULES_DEFAULT_RELEASES
unset PMODULES_DEFAULT_GROUPS
unset PMODULES_DEFINED_RELEASES

replace_path PATH    "${PMODULES_HOME%/*}/.*"
replace_path MANPATH "${PMODULES_HOME%/*}/.*"
append_path  PATH    "${PMODULES_HOME}/bin"
append_path  MANPATH "${PMODULES_HOME}/share/man"

#############################################################################
# initialize bash completion
#
if [[ -r "${PMODULES_HOME}/init/bash_completion" ]]; then
	source "${PMODULES_HOME}/init/bash_completion"
fi

#############################################################################
# legacy...
#
unset MODULE_VERSION
unset MODULE_VERSION_STACK
unset MODULESHOME

# Local Variables:
# mode: sh
# sh-basic-offset: 8
# tab-width: 8
# End:
