#%Module1.0

module-whatis       "Conda package manager and Anaconda software distribution"
module-url          "https://www.anaconda.com/"
module-license      "3-clause BSD License and 3rd party software licenses. https://docs.continuum.io/anaconda/eula/"
module-maintainer   "Spencer Bliven <spencer.bliven@psi.ch> / Derek Feichtinger <derek.feichtinger@psi.ch>"

module-help         "
Anaconda is a package manager, an environment manager, a Python/R data science
distribution, and a collection of over 1,500+ open source packages. Anaconda is
free and easy to install, and it offers free community support.

Conda is an open source package management system and environment management
system that runs on Windows, macOS and Linux. Conda quickly installs, runs and
updates packages and their dependencies. Conda easily creates, saves, loads and
switches between environments on your local computer. It was created for Python
programs, but it can package and distribute software for any language.

Conda as a package manager helps you find and install packages. If you need a
package that requires a different version of Python, you do not need to switch
to a different environment manager, because conda is also an environment
manager. With just a few commands, you can set up a totally separate
environment to run that different version of Python, while continuing to run
your usual version of Python in your normal environment.

This package provides the conda command (miniconda), as well as releases of the
Anaconda distribution, built against several python versions.
"

# this package has conflicts with all older psi python installations which
# integrated conda into the psi-python
conflict  psi-python27
conflict  psi-python34
conflict  psi-python35
conflict  psi-python36
conflict  psi-python37


# These paths are managed by the sourced conda file. Pmodules should not touch it
set dont-setenv { LD_LIBRARY_PATH }
set dont-setenv { PATH }

# Check for supported shell types
set shelltype [module-info shelltype]
switch -- $shelltype {
    "sh" {
    }
    default {
        puts stderr "Shells of type '$shelltype' are NOT supported!"
    }
}

switch [module-info mode] {
    "load" {
        #TODO check whether another conda version is present (conflicts)
        # pmodules itself seems to prevent loading the same module of a different version
        # but we need to prevent conflicts with a conda from a different source.

        # puts stderr "DEBUG: Using conda from $P/$V\n"
        puts stdout "source \"$PREFIX/conda/etc/profile.d/conda.sh\";\n"

        # Activate base? No: anaconda should just provide the conda tool
        #puts stdout "conda activate;\n"


        # Safety check! Warn if an admin loads anaconda on an auristor system
        catch {
            # Check if we're running auristor
            set afsversion [exec fs --version]
            if [regexp -nocase {^auristor} $afsversion] {

                # Admin groups for this module (regex format)
                set admins {sys.modules:administrators|sys.modules:psi_python}

                # Determine current user. Prefer klist, but fall back to $USER
                catch {
                    exec klist 2>/dev/null | sed -E -n {s/.*principal: ([^@]+)(@.*)?$/\1/p};
                } principal option
                if { [dict get $option -code] != 0} {
                    set principal $::env(USER)
                }

                # Determine whether the user belongs to one of the admin groups
                if [regexp $admins [exec pts mem $principal]] {
                    puts stderr "WARNING: You have loaded the anaconda module on an Auristor system. Do not install packages!"
                }
            }
        }
    }

    "unload" -
    "remove" {
        # Only run this if conda is in the PATH
        catch {exec which conda} result option
        if { [dict get $option -code] != 0 } {
            puts stderr "Error: cannot cleanly unload anaconda: conda is not in the PATH"
        } else {
            # if the user has invoked this from a subshell, the conda
            # functions may not be defined even though a conda
            # executable is still in the path ! One could try the
            # following, but currently we leave it commented.
            # puts stdout {if [[ x$(command -v conda) != xconda ]];then source $(conda info --base)/etc/profile.d/conda.sh; fi;}

            # If the conda env is intact (conda defined as a function), then
            # deactivate all layers of active conda environments
            puts stdout {if [[ x$(command -v conda) == xconda ]]; then while [[ "${CONDA_SHLVL:-0}" -gt 0 ]]; do [[ $PMODULES_DEBUG == 1 ]] && echo "unloading conda env $CONDA_DEFAULT_ENV..." >&2; conda deactivate; [[ $PMODULES_DEBUG == 1 ]] && echo $PATH >&2; done; fi;}

            # the path cleaning cannot use tcl remove-path, since at this point tcl
            # is not aware that the above bash statements will have modified the path
            # upon the eval that is done by the outer "module" function.

            puts stdout {PATH=$(echo $PATH| tr ':' '\n' | grep -v "$PREFIX/conda/condabin" | tr '\n' ':'); export PATH=${PATH%:};}

            # remove the conda function definitions
            unsetenv __conda_activate
            unsetenv __conda_hashr
            unsetenv __conda_reactivate
            unsetenv conda

            unsetenv CONDA_EXE
            unsetenv CONDA_PYTHON_EXE
            unsetenv CONDA_SHLVL
            unsetenv _CE_CONDA
        }
    }
}

